#!/usr/bin Rscript
options(warn=1)
rm(list=ls())
require("segmented")

#Usage: Rscript core_cov.R bifido_corecov_170329.txt

#This R-script will estimate the coverage at the terminus, using the summed core gene family coverages. If the cov-ter cannot be properly estimated (fx. due to draft genome status or lack of replication), an estimate will be generated using the median coverage across core gene families, and the PTR is set to NA. If more than 20% of the core gene families have no coverage, the abundance will be set to zero. As output, a tabular file is generated (including the cov-ter/median cov, and PTR), and a pdf-file with plots for visual validation.

##Functions for script

#Filter outliers. Genes with coverage 2x bigger or smaller than the median coverage are removed. 

filter <- function(data_subset) {
	 diff1 <- abs(data_subset$Coverage-median(data_subset$Coverage))
	 frame1 <- cbind(data_subset, diff1)
	 filt1 <- subset(frame1,diff1< (2*median(frame1$Coverage)))
	 return(filt1)
}


#Fit segmented regression lines. Done with the package "segmented". The estimated break-point is calculated as half the max gene pos (which should be close to the actual genome length). A model containing the two fitted regression lines is generated when possible. If not, a vector is created, with the value "NA".

fit_line <- function(data_filt) {
	 x <- data_filt$Ref_pos
	 y <- data_filt$Coverage
	 psi_est <- max(x)/2
	 lin.mod <- lm(y~x)
	 seg.mod <-tryCatch(segmented(lin.mod, seg.Z=~x, psi=psi_est), error=function(e) "NA")
	 return (seg.mod)
}

#Get coordinates from the regression lines. I have added two check-points here: First; If the break-point is too far from the expected place (+/-50% of break-point estimate), ptr is set to 1. Second; If the coverage at ori (either beginning or endof dataframe) is lower than the estimated coverage at ter, ptr is also set to 1. 

get_coord <- function(seg.mod,x) {
	  if(is.list(seg.mod)) {
               psi <- (summary.segmented(seg.mod)[[12]])[2]
               psi_est <- max(x)/2
               psi_est <- max(x)/2
               psi_min <- psi_est-(0.5*psi_est)
               psi_max <- psi_est+(0.5*psi_est)
               intercept1 <- (intercept(seg.mod)[[1]])[1]
               intercept2 <- (intercept(seg.mod)[[1]])[2]
               slope1 <- (slope(seg.mod)[[1]])[1]
               slope2 <- (slope(seg.mod)[[1]])[2]
               cov_ter <- slope1*psi + intercept1
               cov_ori2  <- slope2*(tail(x, n=1)) + intercept2
               max_ori_cov <- max(intercept1, cov_ori2)
               min_ori_cov <- min(intercept1, cov_ori2)
               diff <- max_ori_cov-min_ori_cov
               if ((psi<psi_min) || (psi>psi_max) || (min_ori_cov<cov_ter)){
                  ptr <- NA
               }
               else {
                  ptr <- max_ori_cov/cov_ter
               }
               outlist <- c(cov_ter,ptr,diff)
	       return(outlist)
          }
	  else {
	       outlist <- c(NA,NA,NA)
	       return(outlist)
          }
}

##data acquisition. The script assumes the output as generated by the script core_cov.pl

Args <- commandArgs(trailingOnly=TRUE)
argument <- Args[1]
data <- read.table(argument,h=T, check.names=FALSE)
clusters <- levels(data$SDP)
samples <- levels(data$Sample)

##prep for output. Output files will be named according to the input-file

outfile_prefix <- substr(Args[1],1,nchar(Args[1])-4)
outfile_plot <- paste0(outfile_prefix,".pdf")
outfile_table <- paste0(outfile_prefix,"_coord.txt")
coord_table <- data.frame(Cluster=character(),Sample=character(),Cov_ter=numeric(),Ptr=numeric(),Diff=numeric(),stringsAsFactors=FALSE)
cairo_pdf(outfile_plot, onefile=TRUE)
par(mfrow=c(4,3),pty="s", oma=c(3,3,0,0),mar=c(2,1.5,2,1.5))

##process data and generate output. If more than 20% of the core-genes have zero coverage, coverage is set to zero, and no plot is created. If the PTR was set to 1, the median will be plotted and used for quantification. Else, the segmented regression line is plotted, and the terminus coverage is used for quantification.

for (i in clusters) { 
    for (j in samples) {
    	data_subset <- subset(data, data$SDP==i & data$Sample==j,select=Ref_pos:Coverage)
        nb_genes <- length(data_subset$Coverage)
        cov_genes <- length(which(data_subset$Coverage>1))
	cov_perc <- cov_genes/nb_genes        
        cov_median <- median(data_subset$Coverage)	
	if (cov_perc < 0.8) {
	   coord_table[nrow(coord_table)+1,] <- c(i,j,0,"NA","NA")
           next
        }
	else {
	     data_filt <- filter(data_subset)
 	     nb_genes_filt <- length(data_filt$Coverage)
             y_max <- max(data_filt$Coverage)
             y_max_round <- ceiling(y_max/50)*50
	     x_max <- max(data_filt$Ref_pos)
	     x_max_round <- ceiling(x_max/50)*50
	     main_title <- paste0(i,": ",j)
	     plot(data_filt$Ref_pos,data_filt$Coverage,ylim=c(0,y_max_round),xlab="",ylab="",main=main_title,cex.main=0.9,pch=20,cex=0.4,cex.axis=0.8, font.main=1)
	     grid(col="gray 40")
	     seg.mod <- fit_line(data_filt)
	     mtext("Coverage (reads/bp)",outer=TRUE,side=2,line=1,font=1)
	     mtext("Genome position (bp)", outer=TRUE, side=1,line=2,font=1)
	     coord <- get_coord(seg.mod,data_filt$Ref_pos)
	     if (is.na(coord[2])) {
	         cov <- median(data_filt$Coverage)
                 coord_table[nrow(coord_table)+1,] <- c(i,j,cov,"NA","NA")
                 abline(h=cov,col="red",lwd=2)
             }
	     else {
                  coord_table[nrow(coord_table)+1,] <- c(i,j,coord[1],coord[2],coord[3])
                  plot(seg.mod,add=T,col="red",lwd=2)  
             }
    	}
    }
}
write.table(coord_table,file=outfile_table,row.names=FALSE,quote=FALSE,sep="\t")
dev.off()
